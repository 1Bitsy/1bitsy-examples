#!/usr/bin/env python3

"""freq-calculator - Calculate PLL coefficients.

    Given an HSE frequency, a PLLM value, a desired I2S sample rate
    and whether I2S MCK is needed, calculate coefficients for RCC
    I2SPLM and SPI I2SDIV.
"""

import argparse
from math import floor, ceil
import sys

# The STM32F4 Reference Manual says:
#   fVCO must be between 100 MHz and 432 MHz.
#   Denominator is R * D.  2 <= R <= 7, and 4 <= D <= 511. 

FVCO_MIN, FVCO_MAX = 100000000, 432000000
R_MIN, R_MAX = 2, 7
D_MIN, D_MAX = 4, 511

def solve(freq_in, freq_out, has_mck=False):
    # fVCO goes from 192 to 432.
    # Denominator goes from 2*4 to 7*511 and has a factor between 2 and 7.
    
    numerators = iter(range(ceil(FVCO_MIN / freq_in),
                            floor(FVCO_MAX / freq_in) + 1))
    denominators = iter(sorted(set(r * d
                                   for r in range(R_MIN, R_MAX)
                                   for d in range(D_MIN, D_MAX))))
    num = next(numerators)
    den = next(denominators)
    min_err = float('+inf')
    best = None

    try:
        while True:
            f = freq_in * num / den
            err = f - freq_out
            # print('num={0} den={1} f={2:.8g} err={3:.8g}'
            #       .format(num, den, f, err))
            if abs(err) < abs(min_err):
                min_err = err
                best = {'num': num, 'den': den}
            if err <= 0:
                num = next(numerators)
            else:
                den = next(denominators)
    except StopIteration:
        pass
                
    return best


def print_coefficients(num, den, hse, pllm, other):
    r_values = [r for r in range(2, 8) if not den % r and den // r <= D_MAX]
    assert r_values, 'denominator should have a factor between 2 and 7.'
    r = r_values[0]
    d = den // r
    assert r * d == den
    assert R_MIN <= r <= R_MAX
    assert D_MIN <= d <= D_MAX, '%r' % d

    # d is split into I2SDIV and ODD.
    i2sdiv = d // 2
    odd = d % 2

    print('/* begin coefficients generated by freq-calculator.py */')
    print('/* HSE = {0}, PLLM = {1}, {2} */'.format(hse, pllm, other))
    print('#define PLLI2S_N_VALUE {0}'.format(num))
    print('#define PLLI2S_R_VALUE {0}'.format(r))
    print('#define I2SPR_I2SDIV_VALUE {0}'.format(i2sdiv))
    print('#define I2SPR_ODD_VALUE {0}'.format('SPI_I2SPR_ODD' if odd else 0))
    print('/* end coefficients generated by freq-calculator.py */')


def main(argv):
    ap = argparse.ArgumentParser(description='Calculate I2S PLL coefficents.')
    ap.add_argument('HSE', type=int, help='HSE frequency')
    ap.add_argument('PLLM', type=int, help='PLLM value')
    ap.add_argument('Fs', type=float, help='desired sample rate')
    ap.add_argument('--mck', action='store_const', const=True,
                    help='generate I2S MCK output at 256*Fs')
    ap.add_argument('--bits', action='store',
                    type=int, default=16, choices=[16, 32],
                    help='bits per sample (default 16)')
    args = ap.parse_args(argv[1:])
    # print(args)
    freq_in = args.HSE / args.PLLM          
    freq_out = args.Fs * (256 if args.mck else 2 * args.bits)
    has_mck = args.mck
    values = solve(freq_in, freq_out, has_mck=has_mck)
    if args.mck:
        other = 'MCK = 256 * Fs'
    else:
        other = '{0} bits/sample'.format(args.bits)
    print_coefficients(num=values['num'], den=values['den'], hse=args.HSE, pllm=args.PLLM, other=other)


if __name__ == '__main__':
    sys.exit(main(sys.argv))
