#include "i2s.h"

#include <assert.h>
#include <stdio.h>

#include <libopencm3/cm3/nvic.h>
#include <libopencm3/stm32/rcc.h>

static i2s_sample_callback *spi2_callback;
static i2s_channel spi2_left_right;

static i2s_sample_callback *spi3_callback;
static i2s_channel spi3_left_right;


// RM0090, Section 28.4.5:
//
//   I2S Master Mode
//
//   Procedure
//
//   1. Select the I2SDIV[7:0] bits in the SPI_I2SPR register to
//   define the serial clock baud rate to reach the proper audio
//   sample frequency. The ODD bit in the SPI_I2SPR register also has
//   to be defined.
//
//     I used freq_calculator.py.
//       HSE  = 25 MHz
//       PLLM = 25
//       Fs = 44100 Hz
//       MCK  = true
//
//
//   2. Select the CKPOL bit to define the steady level for the
//   communication clock. Set the MCKOE bit in the SPI_I2SPR register
//   if the master clock MCK needs to be provided to the external
//   DAC/ADC audio component (the I2SDIV and ODD values should be
//   computed depending on the state of the MCK output, for more
//   details refer to Section 28.4.4: Clock generator).
//
//     SPI_I2SCFGR.CKPOL = 1;
//     SPI_I2SPR.MCKOE = 1;
//
//
//   3. Set the I2SMOD bit in SPI_I2SCFGR to activate the I2S
//   functionalities and choose the I2S standard through the
//   I2SSTD[1:0] and PCMSYNC bits, the data length through the
//   DATLEN[1:0] bits and the number of bits per channel by
//   configuring the CHLEN bit. Select also the I2S master mode and
//   direction (Transmitter or Receiver) through the I2SCFG[1:0] bits
//   in the SPI_I2SCFGR register.
//
//     SGTL5000's CHIP_I2S_CTRL register is programmed:
//        SCLKFREQ = 1     (SCLK = Fs * 32)
//        MS       = 0     (slave)
//        SCLK_INV = 0     (data valid on rising edge of SCLK)
//        DLEN     = 0b11  (data length 16 bits)
//        I2S_MODE = 0     (I2S mode)
//        LRALIGN  = 0     (data word starts 1 I2S_SCLK delay
//                          after I2S_LRCLK transition)
//        LRPOL    = 0     (LRCLK 0 = left, 1 = right)
//
//     So...
//       SPI_I2SCFGR.I2SMOD = I2SMOD (1);
//       SPI_I2SCFGR.I2SSTD = I2S_PHILIPS (0b00);
//       SPI_I2SCFGR.DATLEN = 16BIT (0b00);
//       SPI_I2SCFGR.CHLEN  = 0 (16 bits);
//       SPI_I2SCFGR.I2SCFG = MASTER_TRANSMIT (0b10);
//
//
//   4. If needed, select all the potential interruption sources and
//   the DMA capabilities by writing the SPI_CR2 register.
//
//     May as well just get one interrupt per sample (two per frame).
//
//     SPI_CR2.TXEIE = 1;
//     nvic_enable_irq(NVIC_SPI2_IRQ);
//
//
//   5. The I2SE bit in SPI_I2SCFGR register must be set.
//
//     SPI_I2SCFGR.I2SE = I2SE (1);
//
//   WS and CK are configured in output mode. MCK is also an output,
//   if the MCKOE bit in SPI_I2SPR is set.


/* begin coefficients generated by freq-calculator.py */
/* HSE = 25000000, PLLM = 25, MCK = 256 * Fs */
#define PLLI2S_N_VALUE 429
#define PLLI2S_R_VALUE 2
#define I2SPR_I2SDIV_VALUE 9
#define I2SPR_ODD_VALUE SPI_I2SPR_ODD
/* end coefficients generated by freq-calculator.py */


extern void init_i2s(const i2s_config *cfg, const i2s_instance *inst,
                     i2s_sample_callback *callback)
{
    uint32_t base = inst->i2si_base_address;

    // Just handle one case for now.
    assert(cfg->i2sc_sample_frequency == 44100);
    assert(cfg->i2sc_mode             == I2SM_MASTER_TX);
    assert(cfg->i2sc_standard         == I2SS_LSB);
    assert(cfg->i2sc_data_format      == I2SF_16);
    assert(cfg->i2sc_mclk_output      == I2SM_ENABLED);
    assert(cfg->i2sc_cpol             == I2SC_CPOL_HIGH);
    assert(cfg->i2sc_clock_source     == I2SC_PLL);
    assert(cfg->i2sc_full_duplex      == false);
    
    switch (base) {

    case SPI2_BASE:
        spi2_callback = callback;
        spi2_left_right = I2SC_LEFT;
        break;

    case SPI3_BASE:
        spi3_callback = callback;
        spi3_left_right = I2SC_LEFT;
        break;

    default:
        assert(false && "i2s: unknown bad address");
    }

    // Enable clock.
    rcc_periph_clock_enable(RCC_SPI2);

    // Enable GPIO pins.
    size_t pin_count = 3 + !!cfg->i2sc_mclk_output + !!cfg->i2sc_full_duplex;
    gpio_init_pins(cfg->i2sc_gpio_pins, pin_count);

    // Enable interrupt.
    nvic_enable_irq(NVIC_SPI2_IRQ);

    SPI_I2SCFGR(base)  = 0;

    RCC_PLLI2SCFGR     = PLLI2S_N_VALUE << RCC_PLLI2SCFGR_PLLI2SN_SHIFT
                       | PLLI2S_R_VALUE << RCC_PLLI2SCFGR_PLLI2SR_SHIFT;

    SPI_I2SPR(base)    = SPI_I2SPR_MCKOE
                       | I2SPR_ODD_VALUE
                       | I2SPR_I2SDIV_VALUE;
    
    SPI_I2SCFGR(base)  = SPI_I2SCFGR_I2SMOD
                       | SPI_I2SCFGR_I2SCFG_MASTER_TRANSMIT
                         << SPI_I2SCFGR_I2SCFG_LSB
                       | SPI_I2SCFGR_I2SSTD_I2S_PHILIPS
                         << SPI_I2SCFGR_I2SSTD_LSB
                       | SPI_I2SCFGR_CKPOL
                       | SPI_I2SCFGR_DATLEN_16BIT
                         << SPI_I2SCFGR_DATLEN_LSB;

    SPI_CR2(base)     |= SPI_CR2_TXEIE;

    // Start the I2S PLL.
    RCC_CR |= RCC_CR_PLLI2SON;

    // Enable I2S.
    SPI_I2SCFGR(base) |= SPI_I2SCFGR_I2SE;
}

void spi2_isr()
{
    int16_t next_sample = 0;
    if (spi2_callback)
        next_sample = (*spi2_callback)(spi2_left_right);
    spi2_left_right = !spi2_left_right;
    SPI2_DR = next_sample;
    uint16_t sr = SPI2_SR;
    if (sr & ~(SPI_SR_BSY | SPI_SR_CHSIDE))
        fprintf(stderr, " ISR: SPI2_SR = %#x\n", sr);
}
